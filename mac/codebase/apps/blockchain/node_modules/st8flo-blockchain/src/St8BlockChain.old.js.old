(function () {

	St8.Libraries('core')
		.add('storage.blockChain', function (options) {
			options = options || {};

			var moduleConstructor = function (Module) {

				var moduleData = {};
				moduleData.blockChains = {};
				const CHAINSTATUS = {
					committed: 1,
					inFlux: 2
				};

				const CHAINVERIFY = {
					none:1,
					quick:2,
					full:3
				};


				/* ------------------------ St8Consensus  --------------------

					Represents an algorithm designed to return a valid consensus
					on a given range of ChainIDs or BlockIDs

					has the following methods -
						requestor - this generates a request based on required chainID / blockID. The request is sent out to participating threads
						responder - this generates responses based on incoming requests from other threads. The response is sent back to requesting thread.
						collector - this collects incoming responses from other threads
						processor - this processes the collected responses to generate a consensus on which is the right value

					Default algorithm : simple majority.
					But methods can be overridden for more specialised algorithms.
				*/
				var St8Consensus = function(chain){
					this.chain = chain;
					this.count = 0;
					this.recieved = [];
					this.timeout = null;
					this.timeoutLength = 10000;
					this.minInputs = 3;
					this.routerObj = null;
				};

				/* ------------------------ NOTE - St8Consensus basic methods ------------------ */


				St8Consensus.prototype.reset = function(){
					this.count = 0;
					this.recieved = [];
					this.timeout = null;
					this.timeoutLength = 10000;
					this.minInputs = 3;
					this.router =  null;
					this.resolve = null;
					this.reject = null;
					return this;
				};

				St8Consensus.prototype.init = function(options){
					this.reset();
					this.resolve = options.resolve;
					this.reject = options.reject;
					return this;
				};

				St8Consensus.prototype.start = function(options){

					options = options || {};
					var _self = this;
					var promise = new Promise((res,rej)=>{
						_self.resolve = res;
						_self.reject = rej;
					});

					_self.router = St8.Router()

					.filterBy(() => {
						return this.registry.filter((x) => x && x.params && x.params[Module.moduleName] && x.params[Module.moduleName][_self.chain.chainID]);
					})

					.top(_self.minInputs);

					if(options.blockID){
						_self.router
						.callback(_self.block.collector(options.blockID))
						.when((r)=> r.length() >= _self.minInputs)
						.do(_self.block.requestor(options.blockID))
					}
					else{
						_self.router
						.callback(_self.chain.collector(options.fullChain))
						.when((r)=> r.length() >= _self.minInputs)
						.do(_self.chain.requestor(options.fullChain))
					}

					return promise;
				};


				/* ------------------------ NOTE - St8Consensus CHAIN methods ------------------ */

				/*
					requestor must reject on timeout
					collector must resolve with value.
					all must reject on error
				*/
				St8Consensus.prototype.chain = {};
				St8Consensus.prototype.chain.requestor = function(verify){
					var _self = this;
					return (r)=>{
						r.trigger(Module.Flo('consensus'), {
							chainID: _self.chain.chainID,
							chainSigs:_self.chain.blockList.map(x=>x.block.blockID),
							verify:verify || CHAINVERIFY.quick,
							alg:'default'
						}).allThreads().once();

						_self.timeout = setTimeout(() => {
							console.error('Error - getFromNetwork() for chain ID [%s] timed out. cancelling', _self.chainID);
							if(_self.reject) _self.reject('timed out');
						}, _self.timeoutLength);
					};
				};
				St8Consensus.prototype.chain.responder = function(){
					return (v)=>{
						if(v.chainID){
							var chain = Module.Chain(v.chainID);

							return chain
								.init({localOnly:true})
								.then(()=> chain.diff(v.chainSigs, v.verify))
								.then((res)=> v.res = res);
						}
					};
				};
				St8Consensus.prototype.chain.collector =function(fullChain){
					var _self = this;
					return (v)=>{
						_self.count++;
						_self.recieved.push({threadID: v.from(), chainID:v.chainID, chainValid:v.chainValid})

						if(_self.count >= _self.minInputs){
							if(_self.timeout) clearTimeout(_self.timeout);
							_self.timeout = null;

							var consensus = _self.chain.processor(_self.recieved);

							_self.reset();

							if(_self.resolve) _self.resolve(consensus);
						}
					};
				};
				St8Consensus.prototype.chain.processor = function(responses){
					var poll = {};

					// Poll for counts
					responses.forEach((r)=>{
						if(r.chainValid){
							if(!poll[r.chainID])
								poll[r.chainID] = 0;
							poll[r.chainID]++;
						}
					});

					// determine majority
					var greatest = null;
					var greatestCount = 0;
					Object.keys(poll).forEach((p)=> {
						if (poll[p] > greatestCount) {
							greatestCount = poll[p];
							greatest = p;
						}
					});


					return {
						winners:responses.filter((x)=>x.chainID == greatest),
						losers:responses.filter((x)=>!x.chainValid || x.chainID != greatest)
					}
				};


				/* ------------------------ NOTE - St8Consesus BLOCK methods ------------------ */
				//
				// St8Consensus.prototype.block = {};
				//
				// St8Consensus.prototype.block.requestor = function(blockID){
				// 	var _self = this;
				// 	return (r)=>{
				// 		r.trigger(Module.Flo('consensus'), {
				// 			chainID: _self.chainID,
				// 			blockID: blockID,
				// 			alg:'default'
				// 		}).allThreads().once();
				//
				// 		_self.timeout = setTimeout(() => {
				// 			console.error('Error - getFromNetwork() for chain ID [%s] timed out. cancelling', _self.chainID);
				// 			if(_self.reject) _self.reject('timed out');
				// 		}, _self.timeoutLength);
				// 	};
				// };
				//
				// /*
				// 	Meant to execute on the remote responding thread.
				// 	Sees a block request packet, tries to validate appropriate data and respond
				//
				// 	Quick validates the given chain
				// 	Then, Validates the given blockID on the chain
				// 	& returns "blockValid" as 1 of 3 possible values :
				// 		1> true - block was found & verified.
				// 		2> false - block was found but not valid.
				// 		3> undefined - block wasn't found !
				//
				// */
				// St8Consensus.prototype.block.responder:function(){
				// 	return (v)=>{
				// 		if(v.chainID && v.blockID){
				// 			var chain = Module.Chain(v.chainID);
				//
				// 			return chain
				// 				.init({localOnly:true})
				// 				.then(()=> chain.verify())
				// 				.then((res)=>{
				// 					if(res){
				// 						var block = chain.getBlock(v.blockID);
				// 						if(block){
				// 							return block.verify()
				// 						}
				// 						else
				// 							return Promise.reject();
				// 					}
				// 					else
				// 						return Promise.reject();
				//
				// 				})
				// 				.then((res)=>{
				// 					if(res) v.blockValid = true;
				// 					else v.blockValid = false;
				// 				})
				// 				.catch((e)=>{
				// 					delete v.blockValid; // Ensure it is undefined
				// 				});
				// 		}
				// 	};
				// };
				//
				// /*
				// 	Recieves the responses & pushes them into a local stack.
				// 	Once minimum number of inputs are gathered,
				// 		triggers processor + reset + consensus resolve.
				// */
				// St8Consensus.prototype.block.collector = function(){
				// 	var _self = this;
				// 	return (v)=>{
				// 		_self.count++;
				// 		_self.recieved.push({threadID: v.from(), chainID:v.chainID, blockID:v.blockID, blockValid:v.blockValid})
				//
				// 		if(_self.count >= _self.minInputs){
				// 			if(_self.timeout) clearTimeout(_self.timeout);
				// 			_self.timeout = null;
				//
				// 			var consensus = _self.block.processor(_self.recieved);
				//
				// 			_self.reset();
				//
				// 			if(_self.resolve) _self.resolve(consensus);
				// 		}
				// 	};
				// };
				//
				// /*
				// 	Does the actual determination of majority value
				// */
				// St8Consensus.prototype.block.processor = function(responses){
				// 	var poll = {};
				//
				// 	// Poll for counts
				// 	responses.forEach((r)=>{
				// 		if(r.blockValid){
				// 			if(!poll[r.blockID])
				// 				poll[r.blockID] = 0;
				// 			poll[r.blockID]++;
				// 		}
				// 	});
				//
				// 	// determine majority
				// 	var greatest = null;
				// 	var greatestCount = 0;
				// 	Object.keys(poll).forEach((p)=> {
				// 		if (poll[p] > greatestCount) {
				// 			greatestCount = poll[p];
				// 			greatest = p;
				// 		}
				// 	});
				//
				//
				// 	return {
				// 		winners:responses.filter((x)=>x.blockID == greatest),
				// 		losers:responses.filter((x)=>!x.blockValid || x.blockID != greatest)
				// 	}
				//
				// 	// TODO - notify losers to do integrity check
				//
				// };




				/* ------------------------ St8Block --------------------------------------

					This is the main block container exposed by the module
					and contains the block data & function related to block manipulation.

					Block structure

					St8Block {
						block:{
							data:{
								meta:{
									chainName - name of the chain that this block is part of
									revision - to keep a track of updates.
									blockType - defines the type of block this is
									author - {blockID, chainName}	creator's account block ID which will contain the public key to verify this block with
									accountType - hard / soft - hard implies account file is necessarily on disk & verifiable by system publicKey. Soft means, it's on disk or network
									permission - ?
									minVotes - min required votes for majority validation / retrieval
								},
								parent:<hash>,
								userData - additional user data (this will contain the actual data, files etc)
							},
							blockID : <hex buffer> signature of the entire data block
						}

					}
				*/



				var St8Block = function St8Block() {
					this.statePromise = Promise.resolve();
					return this;
				};


				/* ----------- St8Block methods ---------------*/

				St8Block.prototype.then = function (fn) {
					this.statePromise.then(() => fn());
					return this;
				};
				St8Block.prototype.catch = function (fn) {
					this.statePromise.catch(() => fn());
					return this;
				};

				/*
					Creates a new local block from the provided data
					and assigns it to this St8Block
				*/

				St8Block.prototype.create = function (data, privateKey) {
					options = options || {};
					var _self = this;

					if (typeof data == "object") {

						_self.statePromise = _self.statePromise
							.then(() => {
								if (typeof data == 'object' && typeof privateKey != 'undefined') {
									// sign the payload
									var signature = ed25519.sign({
										message: JSON.stringify(data),
										// also accepts `binary` if you want to pass a binary string
										encoding: 'utf8',
										// node.js Buffer, Uint8Array, forge ByteBuffer, binary string
										privateKey: privateKey
									});

									return {
										data: data,
										blockID: signature.toString('hex')
									}
								} else {
									return Promise.reject('bad params while creating');
								}
							})
							.then((block) => {
								_self.block = block;
							})
							.catch((e) => {
								console.error('Error while creating block - ', e, data);
							});
					}


					return this;
				};

				/*
					verifies signature against a provided publicKey

					//TODO - publicKey should be optional. If not provided - automatically retrieve author publickey and verify
				*/
				St8Block.prototype.verify = function (publicKey) {
					var _self = this;
					_self.statePromise = _self.statePromise
						.then(() => {
							if (publicKey) {
								if (_self.block && _self.block.data && _self.block.blockID) {
									return ed25519.verify({
										// also accepts a forge ByteBuffer or Uint8Array
										message: JSON.stringify(_self.block.data),
										// node.js Buffer, Uint8Array, forge ByteBuffer, or binary string
										signature: _self.block.blockID,
										// node.js Buffer, Uint8Array, forge ByteBuffer, or binary string
										publicKey: publicKey
									});

								} else {
									return Promise.reject('invalid or uninitiated St8Block');
								}
							} else {
								return Promise.reject('invalid publicKey');
							}
						});

					return this;
				};




				/* ----------------------------- St8Chain -----------------------------------------

					This manages the updates blockchain for each topic, and contains a list of all
					topic blocks from the origin to the latest block.

					This is the primary API for creating blockchains.

					St8Chain(id) - either retrieves an existing chain or creates a new empty chain.
								Adding data to an empty chain, results in creating a genesis block.

					Note - If another chain exists on the network with the same ID, this will conflict.
						 and eventual consensus will decide which version is retained.

					Usage -
						var c = Module.Chain('hello')
							.init()
							.then(()=>{
								// do whatever.
							})

						A chain must be init() before it can be used.
						init() loads and readies the chain in memory, for use
						Loading happens in this order, on an FCFS basis
							from memory / cache
							from disk
							from network
							else load blank

						NOTE - Once loaded - blockList must contain St8Block objects
									rather than raw block data.
				*/

				var St8Chain = function (chainID, bcOptions) {
					bcOptions = bcOptions || {};


					if (bcOptions.create === true) {
						this.chainID = chainID;
						this.blockList = [];
						this.status = CHAINSTATUS.committed;
						this.statePromise = Promise.resolve();
					}

					if (moduleData.blockChains[id]) {
						return moduleData.blockChains[id];
					} else {
						bcOptions.create = true;
						return Module.Chain(id, bcOptions);
					}


				};


				/* ------------------------ NOTE - Init Method ----------------------------------

					Initialises the chain before use - as described above in the St8Chain intro

				*/
				St8Chain.prototype.init = function(options){
					options = options || {};
					var _chain = this;
					_chain.queue(()=>{

						// Do loading sequence
						// TODO

						if(options.localOnly){
							// prevent network load
						}

					});
					return _chain;
				};


				/* ------------------------ NOTE - Async exec queue control ------------------ */


				St8Chain.prototype.then = function (fn) {
					this.statePromise = this.statePromise
						.then((e)=>{
							if(typeof e == 'object'){

								if(e.break === true){
									return Promise.resolve(e);
								}

								if(e.skipTillCatch === true){
									return Promise.reject(e);
								}

								if(e.skip === true){
									delete e.skip;
									return Promise.resolve(e);
								}
							}
							else
								return fn(e);
						});
					return this;
				};
				St8Chain.prototype.catch = function (fn) {
					this.statePromise = this.statePromise
						.catch((e)=>{
							if(typeof e == 'object'){
								if(e.break === true)
									return Promise.reject(e);

								if(e.skipTillCatch === true){
									delete e.skipTillCatch;
									return Promise.resolve(e);
								}

								if(e.skip === true){
									delete e.skip;
									return Promise.resolve(e);
								}
							}
							else
								return fn(e);
						});
					return this;
				};


				/* ------------------------ NOTE - Block retrieval / Verification -----------------*/

				St8Chain.prototype.getBlockID = function(){
					if(this.blocklist && this.blocklist.length > 0){
						return this.blocklist[this.blocklist.length - 1].block.blockID;
					}
					else
						return null;
				};
				St8Chain.prototype.getBlock = function(blockID){
					if(blockID){
						return this.blockList.find((x)=>x.block && x.block.blockID == blockID);
					}

					if(this.blocklist && this.blocklist.length > 0){
						return this.blocklist[this.blocklist.length - 1];
					}

					else
						return null;
				};


				/*
					Diffs remote chain's signature set against local chain's, to find out how many steps behind / ahead it is.
					Optionally verifies the local chain before diffing.

					Params:
						chainSigs : ordered array of blockIDs present in the remote chain, to compare against local chain.
						verify (optional) :
								Value 	-	Constant			- 	Effect
								1		- 	CHAINVERIFY.none	- 	no verification, just a direct diff.
								2 		- 	CHAINVERIFY.quick	- 	linking of blocks & latest block signature to be verified against its author's publicKey
								3 		- 	CHAINVERIFY.full	- 	linking of blocks & all block signatures to be verified againt their respective author's publicKeys.


					Returns:
						Object - { diffPoint, diffSigs, valid }
						 	diffPoint:
								index upto which local chain is the same as remote.

							diffSigs:
								array of any remaining local signatures after diffPoint. can be 0

							valid:
								false - local chain is invalid.
								true - local chain is valid.
								undefined - no verification action taken OR error.
				*/
				St8Chain.prototype.diff = function (chainSigs, verify) {

					// TODO
					// Must cater for an empty / non-setup chain and return that as invalid



				};

				/* ------------------------ NOTE - CRUD methods ---------------------------- */


				St8Chain.prototype.add = function (block) {

					// TODO

					// var _chain = this;
					//
					//
					// _chain.status = CHAINSTATUS.inFlux;
					// var author = block.block.data.meta.author;
					// _chain.getFromNetwork(author.chainID,author.blockID)
					// .then((authorBlock)=>{
					// 	var authorBlock;
					// 	if(authorChain.blockList.length > 0 && authorBlock = authorChain.blockList.find((x)=>x.block.)) ){	// Ensure that the retrieved chain for author isn't empty & has the block we need
					// 		block.verify
					//
					// 		// Build & sign block locally
					// 		if (_chain.blockList.length == 0) {
					// 			// Genesis block routine
					//
					// 		} else {
					// 			// Append block routine
					//
					// 		}
					// 	}
					// 	else{
					// 		return {
					// 			skipTillCatch:true
					// 		}
					// 	}
					//
					// })


				};

				/*
					revert back to the last blockID or provided blockID, if it exists in this blockchain.
					blockID - optional - is the id of a block thats present in the blockchain
				*/
				St8Chain.prototype.rollback = function (blockID) {
					// TODO
				};



				/*
					Retrieves either a block (if blockID specified) or the entire chain from the network.
					blockID is optional.

				*/
				St8Chain.prototype.getFromNetwork = function (chainID, options) {
					var _self = this;
					options = options || {};

					var consensus = options.consensus || new St8Consensus(chainID);

					// Temporary data holder for this run of getFromNetwork.
					// Namespaced to avoid conflicts.
					_self.gfnData = {
						count:0,
						recieved:[],
						timeout:null,
						timeoutLength:10000,
						minInputs:3,
						block:null,
						chain:null
					};

					// Queuing on statePromise chain
					_self.then(() => {

						return new Promise((res, rej) => {

							if (!_self.chainRouter) {

								_self.chainRouter = St8.Router().filterBy(() => {
									return this.registry.filter((x) => x && x.params && x.params[Module.moduleName] && x.params[Module.moduleName][chainID]);
								});

							}

							_self.chainRouter

								// Select only as many inputs as needed
								.top(_self.gfnData.minInputs)

								// Setup callback hook to recieve responses with blocks / chains
								.callback((v) => {

									// Only If there's a v.block (when block is expected)
									if(v.blockID || v.chainID){

										_self.gfnData.count++;
										_self.gfnData.recieved.push(v);


										if (_self.gfnData.count >= _self.gfnData.minInputs) {
											clearTimeout(_self.gfnData.timeout);

											if(options.fullChain){
												_self.gfnData.chain = St8Chain.consensus(_self.gfnData.recieved);

												if (!_self.gfnData.chain)
													return rej(new Error('no majority found'));

												res(_self.gfnData.chain);

											}
											else{
												_self.gfnData.block = St8Block.fromConsensus(_self.gfnData.recieved);

												if (!_self.gfnData.block)
													// TODO - Retrive actual data now.
													return rej(new Error('no majority found'));

												res(_self.gfnData.block);
											}

										}
									}

								})

								// Wait till enough valid threads are online
								.when((r)=> r.length() >= _self.gfnData.minInputs )

								// Once condition is valid, send the requests to all & set a timeout.
								.do((r)=>{
									r.trigger(Module.Flo('getChain'), {
										chainID: chainID,
										blockID: options.blockID
									}).allThreads().once();

									_self.gfnData.timeout = setTimeout(() => {
										console.error('Error - getFromNetwork() for chain ID [%s] timed out. cancelling', chainID);
										rej('timed out');
									}, _self.gfnData.timeoutLength);
								});

						})
						.catch((e) => {
							console.log('Error while getting block of chain [%s] from network - ', chainID, e);
						});


					return _self;
				};

				Module.Flo('getChain')
					.start()
					.pipe('load').do((v) => {
						return Module.db.get(v.chainID)
							.then((chain)=>{
								if(chain && chain.blockList && chain.blockList.length > 0){
									if(v.blockID)
										v.block = chain.blockList.find((x)=>x.blockID == v.blockID)
									else
										v.block = chain.blockList[chain.blockList.length -1];
								}
								else{
									v.block = null;
								}
								return v;
							});
					})
					.pumpFT()
					.end();
				Module.Flo('getFullChain')
					.start()
					.pipe('load').do((v) => {
						return Module.db.get(v.chainID)
							.then((chain)=>{
								if(chain && chain.blockList && chain.blockList.length > 0){
									v.chain = chain;
								}
								else{
									v.chain = null;
								}
								return v;
							});
					})
					.pumpFT()
					.end();



				Module.Chain = St8Chain;
				Module.constants = {};
				Module.constants.CHAINSTATUS = CHAINSTATUS;

			}
			return moduleConstructor;

		});


})();
